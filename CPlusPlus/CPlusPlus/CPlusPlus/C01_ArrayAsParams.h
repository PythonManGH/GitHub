#pragma once

//int a[] = { 33,654,4,455,6,33,4 };

/** 数组名和数组的首地址 ***********************************************************************
std::cout << a << std::endl;
std::cout << &(a[0]) << std::endl;
// a 和 &(a[0])其实是一样，数组名就是数组的首地址

/** 获取数组的个数 *****************************************************************************
int num = sizeof(a) / sizeof(a[0]);

/** 数组传参 ***********************************************************************************

/** 下面这两个函数无法构成重载 所以说明一个问题：这两个函数的参数一摸一样 
void fun(int a[2]) // 其实[]中写与不写，写的是多少根本不受影响，表达的就是 int *a
{
	std::cout << a << std::endl;
}
void fun(int *a){}
*/


/** 下面这两个函数可以构成重载
void fun(int a[2])
{
std::cout << a << std::endl;
}
void fun(int *a){}
*/


/*
int a[] = { 33,654,4,455,6,33,4 };
int num = sizeof(a) / sizeof(a[0]); 
std::cout << num << std::endl; 7
void fun(int *a)
{
	std::cout << a << std::endl;
	int num = sizeof(a)/sizeof(a[0]);  这个num和上面的num不一样
	std::cout << num << std::endl; 2 应该是 1 不知道为什么是 2
}
*/


int b[10] = { 0,1,2,3,4,5,6,7,8,9 };

std::cout << "b:" << b << std::endl;
std::cout << "&b:" << &b << std::endl;
std::cout << "********************************************************************************" << std::endl;

std::cout << "b+1:" << b + 1 << std::endl;     // b代表数组首元素的地址
std::cout << "&b+1:" << &b + 1 << std::endl;    // &b代表整个数组的地址 
std::cout << "********************************************************************************" << std::endl;

std::cout << "*b:" << *b << std::endl;
std::cout << "*(&b):" << *(&b) << std::endl;
std::cout << "********************************************************************************" << std::endl;

std::cout << "*(b + 1):" << *(b + 1) << std::endl;     // b代表数组首元素的地址
std::cout << "*(&b + 1):" << *(&b + 1) << std::endl;    // &b代表整个数组的地址 
std::cout << "********************************************************************************" << std::endl;