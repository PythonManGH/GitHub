1. 计算机组成
	处理器，主存储器，输入输出模块，系统总线(各个部件之间的通讯设备)
2. Linux操作系统的基本组成
	内核(kernel):内核帮我们管理进程，管理内存，管理设备的驱动程序，管理文件系统，网络系统，负责帮我们和硬件进行通信，内核决定了系统的稳定性和可靠性
	Shell:也是一个软件，提供了一个用户界面的软件，用户可以shell上面输入一些命令，命令执行的结果可以在shell上面显示出来，shell的命令最终会交给内核执行
	文件系统：
	各种各样的应用程序：




编译 .o 文件
	gcc -o io.o -Iinclude -c io.c
		-o : 指定.o文件的路径和名称
		-I : 指定所需头文件的路径(不需要名称)
		-c : 指定源文件路径和名称
	gcc -o cat -I. main.c io.c	


1.进程
	什么是程序？什么是进程？进程和程序的区别？进程的特性？
	1.1程序的概念：存放在磁盘中的可执行文件，程序是指完成某些事物的一种既定方式和过程，可以将程序看成是一系列动作的执行过程的描述。在百度百科中，计算机程序被定义为“
		一组指示计算机执行动作或做出判断的指令，通常用某种程序设计语言编写，运行于某种目标体系结构上”。
	1.2什么是进程：程序的执行实例被成为进程，或者说正在运行的程序，进程是系统进行资源分配和调度的基本单位，进程的概念主要有两点：第一，进程是一个实体。每一个进程都有
		它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域
		存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处
		理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。进程具有独立的权限与职责。如果系统中某个进程崩溃，他不会影响到其余的进程
		每个进程运行在各自的虚拟地址空间中，进程之间可以通过由内核控制的机制相互通讯
	1.3进程和程序的区别：
		程序是永存的；进程是暂时的，是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；
		程序是静态的观念，进程是动态的观念；
		进程具有并发性，而程序没有；
		进程是竞争计算机资源的基本单位，程序不是。
		进程和程序不是一一对应的： 一个程序可对应多个进程即多个进程可执行同一程序； 一个进程可以执行一个或几个程序 
	1.4进程的特征：
		动态性：是程序的一次执行；
		并发性：进程是可以并发执行；
		独立性：是系统进行资源分配和调度的一个独立单位；
		异步性：进程间的相互制约，使进程执行具有间隙；
		结构性：进程是具有结构的。
	1.5进程在内核中的结构
		task_struct(这是个结构体，又被称为进程表项，有的也称他为进程控制块)
			state : 进程的状态-->#define TASK_RUNNING        0//进程要么正在执行，要么准备执行
				#define TASK_INTERRUPTIBLE  1 //可中断的睡眠，可以通过一个信号唤醒
				#define TASK_UNINTERRUPTIBLE    2 //不可中断睡眠，不可以通过信号进行唤醒
				#define __TASK_STOPPED      4 //进程停止执行
				#define __TASK_TRACED       8 //进程被追踪
				/* in tsk->exit_state */ 
				#define EXIT_ZOMBIE     16 //僵尸状态的进程，表示进程被终止，但是父进程还没有获取它的终止信息，比如进程有没有执行完等信息。                     
				#define EXIT_DEAD       32 //进程的最终状态，进程死亡
				/* in tsk->state again */ 
				#define TASK_DEAD       64 //死亡
				#define TASK_WAKEKILL       128 //唤醒并杀死的进程
				#define TASK_WAKING     256 //唤醒进程
			flags
			need_resched
			counter
			priority : 进程的调度策略
			...
        1.6 The starting procedure of a C program
		在main启动之前，内核会启动一个特殊例程(被称为启动例程)(一个动态库.so)
	1.7 启动例程的作用
		搜集命令行的参数传递给main函数中的argc和argv
		搜索环境信息(比如环境变量)构建环境表并传递给main函数
		登记进程的终止函数(释放资源的函数)
	1.8 进程终止的方式
		正常方式：从main函数返回，调用exit(c函数)，调用_exit(系统调用)，最后一个线程从其启动例程返回，最后一个线程调用pthread_exit
		异常终止：调用abort,接受到一个信号并终止，最后一个线程对取消请求作处理响应	
        1.9 自定义终止函数
		每个启动的进程都默认的向内核登记了一个标准的进程终止函数
		终止函数在进程终止时释放进程所占用的一些资源
		登记的多个终止函数的执行顺序是以栈的方式进行，先登记的后执行
		登记的接口：
			#include<stdlib.h>
			int atexit(void (*function)(void))
			返回：若成功返回0，若出错则为-1 
	1.10查看进程的信息
		[root@localhost Linux]# ps -ef | more  查看所有
		[root@localhost Linux]# ps -aux | more 查看所有
	1.11 进程常见的状态
		运行状态，等待状态，停止状体，僵尸状态
	1.12 进程的调度，CPU如何对进程进行调度
		操作系统分为抢占式和非抢占式，

	守护进程：是生存期长的一种进程，它们常常在系统引导装入时启动，在系统关闭时终止，
		所有守护进程都以超级用户(用户ID为0)的优先权运行。
		守护进程的父进程都是init进程
	孤儿进程：父进程，子进程就成为了孤儿进程，会由1号进程领养
	僵尸进程：子进程结束但是没有完全释放内存(内核中的task_struct没有释放),该进程就成为了僵尸进程。
		当僵尸进程的父进程结束后就会被init进程领养，最终被回收。
	避免僵尸进程：方法一：让僵尸进程的父进程回收，父进程每隔一段时间来查询子进程是否结束并回收，调用wait()或者waitpid(),
		通知内核释放僵尸进程。方法二：采用信号SIGCHLD通知处理，并在信号处理程序中调用wait函数。方法三：让僵尸进程成为孤儿进程，由init进程回收。
	
如果调用wait()的进程没有终止的进程而还有一个或多个子进程还在运行，函数将会一直阻塞到现有子进程第一个终止。
waitpid函数则有选项可供控制，waitpid在一个循环里可以获取所有的终止进程。pid指需要等待的进程ID，如果值为-1表示等待第一个终止的进程，options是附加选项，常用的选项是WNOHANG，即没有子进程终止时不阻塞
对于waitpid是wait的升级版本，可以选择非阻塞返回，并且可以等待一个特定的子进程返回， 而不是只是等待第一个结束的子进程返回

exec:当进程调用exec函数时，该进程完全由新程序代换，替换原有进程的正文，而新程序则从其main函数开始执行。因为调用exec
	并不创建新进程，所以前后的进程ID并未改变。exec只是用另一个新程序替换了当前进程的正文，数据，堆，栈
system:exec在创建时一般先创建一个进程，system将这一过程封装了

子进程的继承属性：
	用户信息和权限，目录信息，信号信息，环境，共享存储段，资源限制，堆，栈，数据段，共享代码段。
子进程特有属性
	进程ID，所信息，运行时间，未决信号
操作文件时的内核结构变化
	只继承父进程的文件描述表，不继承但共享文件表项和i_Node
	文件表项中的引用计数加1，当父进程close之后，计数器减1，子进程还是可以使用文件表项，只有当计数器为0才会释放
		文件表项

		
		
	
什么是互斥？什么是同步？

互斥：一个资源一次只能被一个访问者使用（保证访问数据，唯一访问性）

举个例子：你去上厕所，门一开，人进去，门锁上，在你上厕所期间别人不能打扰

同步：当多个访问者一起工作时并对每个访问者访问的时序有一定限制（保证访问数据，时序访问性）

举个例子：你上完厕所，刚出来，本来应该由别人了，但是你此时又进去，你反复的进去出来，导致别人都上不了厕所。因此同步就是保证时序性的，你出来了，应该去后面排队。
为什么要同步与互斥？

1.在运行多个任务，都需要访问同一种资源-----------竞争

2.多个任务之间有依赖关系，某个任务的运行状态依赖于另一个任务

同步互斥就是解决这类问题的。
互斥和同步的联系？

同步是一种更为复杂的互斥，而互斥是一种特殊的同步。

也就是说互斥是两个任务之间不可以同时运行，他们会互相排斥，必须等待一个执行完再执行，而同步也是不能同时运行，但是必须要按照某种次序来运行。但是互斥不限制任务的执行顺序。（互斥任务是无序的，同步任务是有序的）
线程如何实现互斥

互斥量 ：是一个可以处于两态之一的变量，解锁和加锁。用来保护临界资源的。当你访问临界资源的时候，先要申请锁，如果别人还没释放你就被阻塞，如果没人用你就可以加锁，这样就很有效的保证临界资源一段时间内只能被一个人访问。



互斥锁：是一种简单的加锁的方法来控制对共享资源的访问。在同一时刻只能有一个线程掌握某个互斥锁，拥有上锁状态的线程能够对共享资源进行访问。若其它线程希望上锁一个已经被上了互斥锁的资源，则该线程挂起，直到上锁的线程释放互斥锁为止。
	
写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。
在读写锁保持期间也是抢占失效的。
如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。

一次只有一个线程可以占有写模式的读写锁, 但是可以有多个线程同时占有读模式的读写锁. 正是因为这个特性,
当读写锁是写加锁状态时, 在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被阻塞.
当读写锁在读加锁状态时, 所有试图以读模式对它进行加锁的线程都可以得到访问权, 但是如果线程希望以写模式对此锁进行加锁, 它必须直到所有的线程释放锁.
通常, 当读写锁处于读模式锁住状态时, 如果有另外线程试图以写模式加锁, 读写锁通常会阻塞随后的读模式锁请求, 这样可以避免读模式锁长期占用, 而等待的写模式锁请求长期阻塞.
读写锁适合于对数据结构的读次数比写次数多得多的情况. 因为, 读模式锁定时可以共享, 以写模式锁住时意味着独占, 所以读写锁又叫共享-独占锁.
读锁和写锁排斥

条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步 的一种机制，主要包括两个动作：
    一个线程等待"条件变量的条件成立"而挂起；
    另一个线程使 “条件成立”（给出条件成立信号）。

死锁：两个线程试图同时占用两个资源，并按不同的次序锁定相应的共享资源，
	所申请的资源被其他等待线程占有
解决：按相同的次序锁定相应的共享资源，pthread_mutex_trylock()


管道：管道是单向的，数据只能像一个方向流动，管道创建成功，实际获得俩个文件描述符，一个用于读取而另一个用于写入，管道主要用于父子进程间的通信

消息队列：消息队列是内核中一个连表，一个进程发送消息，一个进程读取消息
共享内存：被多个进程所共享的一块物理内存，多个进程都可以把该共享内存映射到自己的虚拟内存空间。这是进程间通信最快的方法，但是它本身不提供同步机制，可通过信号量进行同步。
信号量：主要用于进程间通信的互斥和同步

